// Main.java
// This is a complete, single-file Java program that simulates a multithreaded bank.

import java.util.ArrayList;
import java.util.List;

public class main {

    /**
     * BankAccount: shared resource accessed by multiple ATM threads.
     * All methods that modify balance/history are synchronized to ensure thread-safety.
     */
    static class BankAccount {
        private int balance;                       // account balance (shared resource)
        private final List<String> transactionHistory; // in-memory transaction log

        // Constructor: initialize balance and log the creation
        public BankAccount(int initialBalance) {
            this.balance = initialBalance;
            this.transactionHistory = new ArrayList<>();
            transactionHistory.add("Account created with balance: " + initialBalance);
        }

        /**
         * deposit: synchronized so only one thread can modify balance at a time.
         * Uses notifyAll() to wake waiting withdrawers if balance was low.
         */
        public synchronized void deposit(int amount, String threadName) {
            balance += amount; // update balance
            String log = threadName + " deposited: " + amount + " | Balance: " + balance;
            System.out.println(log);

            // record transaction (safe because method is synchronized)
            transactionHistory.add(log);

            // wake up any waiting threads (withdraw) so they can re-check balance
            notifyAll();
        }

        /**
         * withdraw: synchronized. If balance is insufficient, the thread waits()
         * until a deposit increases the balance. Uses while-loop to recheck condition
         * after waking (standard wait/notify pattern).
         */
        public synchronized void withdraw(int amount, String threadName) {
            while (balance < amount) {
                String waitingLog = threadName + " wants to withdraw " + amount
                        + " but balance is low (" + balance + "). Waiting...";
                System.out.println(waitingLog);
                transactionHistory.add(waitingLog);
                try {
                    wait(); // release lock and wait to be notified
                } catch (InterruptedException e) {
                    // restore interrupt status and exit method gracefully
                    Thread.currentThread().interrupt();
                    String interruptedLog = threadName + " was interrupted while waiting.";
                    System.out.println(interruptedLog);
                    transactionHistory.add(interruptedLog);
                    return;
                }
            }

            // enough balance -> perform withdrawal
            balance -= amount;
            String log = threadName + " withdrew: " + amount + " | Balance: " + balance;
            System.out.println(log);
            transactionHistory.add(log);
        }

        // Get the final balance (no modification, safe to call after threads join)
        public int getBalance() {
            return balance;
        }

        // Return a copy of transaction history to avoid exposing internal list
        public List<String> getTransactionHistory() {
            return new ArrayList<>(transactionHistory);
        }
    }

    /**
     * BankingTask: Runnable that simulates an ATM performing a sequence
     * of deposits and withdrawals.
     */
    static class BankingTask implements Runnable {
        private final BankAccount account;
        private final String threadName;

        public BankingTask(BankAccount account, String threadName) {
            this.account = account;
            this.threadName = threadName;
        }

        @Override
        public void run() {
            // Each ATM does 3 deposit-withdraw cycles
            for (int i = 1; i <= 3; i++) {
                account.deposit(100 * i, threadName); // deposit 100, 200, 300
                try {
                    Thread.sleep(500); // simulate delay between operations
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println(threadName + " interrupted while sleeping.");
                    return;
                }
                account.withdraw(50 * i, threadName); // withdraw 50, 100, 150
            }
        }
    }

    /**
     * main: entry point. Creates a shared BankAccount, starts several ATM threads,
     * waits for them to finish, then prints final balance and full transaction history.
     */
    public static void main(String[] args) {
        // Create account with initial balance 500
        BankAccount account = new BankAccount(500);

        // Create ATM threads
        Thread atm1 = new Thread(new BankingTask(account, "ATM-1"));
        Thread atm2 = new Thread(new BankingTask(account, "ATM-2"));
        Thread atm3 = new Thread(new BankingTask(account, "ATM-3"));

        // Start threads
        atm1.start();
        atm2.start();
        atm3.start();

        // Wait for threads to finish
        try {
            atm1.join();
            atm2.join();
            atm3.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread interrupted while waiting for ATM threads.");
        }

        // Print final balance and transaction history
        System.out.println("\nFinal Account Balance: " + account.getBalance());
        System.out.println("\n=== Transaction History ===");
        for (String log : account.getTransactionHistory()) {
            System.out.println(log);
        }
    }
}
